Interactor Backend Rebuild – TODO Checklist

[x] 0. Baseline sanity checks
    [x] Confirm config/system.json is present and valid (server + fileUploader ports/hosts)
        - Notes: File path `config/system.json`. Required keys: `server.port`, `server.host`, `fileUploader.port`, `fileUploader.host`.
    [x] Start backend and verify /health, /api/modules, /api/interactions endpoints
        - Notes: Run from `backend/`: `npm run dev`. Verify:
          - GET `/health` returns JSON with status/uptime
          - GET `/api/modules` returns manifests loaded by `ModuleLoader`
          - GET `/api/interactions` returns array (may be empty on first run)
    [x] Verify manifests load (ModuleLoader) and logs directory is writable
        - Notes: `backend/src/core/ModuleLoader.ts` loads from `backend/src/modules/**/manifest.json`.
          Ensure `backend/logs/` exists or can be created; check file permissions.

[ ] 1. Critical routing and lifecycle fixes (Time → Audio happy path)
    [ ] Remove route event remapping in /api/interactions/register (keep route.event from source, e.g., "timeTrigger")
        - Notes: Edit `backend/src/index.ts` in the POST `/api/interactions/register` handler.
          Remove the block that maps a route’s event to the target output’s first input event (around where `inputEvents[0].name` is used).
          Goal: preserve `route.event` exactly as provided (e.g., `timeTrigger`).
          Pitfall: If you keep remapping, `MessageRouter` won’t match events emitted by inputs.
    [ ] Create live instances for OUTPUT modules on restore and on register (not just inputs)
        - Notes: In `restoreModuleInstances()`, we currently special-case only `Time Input`.
          - Add a branch for `Audio Output` (displayName `Audio Output` or internal `audio_output`) to call `createModuleInstance(...)` and store the instance in `this.moduleInstances`.
          In `/api/interactions/register`, after building `moduleInstances`, also create live instances for outputs, not only Time.
          Pitfall: Without a live output instance, routed messages have no recipient.
    [ ] Replace ModuleLoader.getInstance() lookups with InteractorServer.moduleInstances registry everywhere
        - Notes: `ModuleLoader.getInstance()` returns `undefined` by design.
          Use `this.moduleInstances.get(moduleId)` inside `InteractorServer` instead.
          Files: `backend/src/index.ts` (`setupTriggerEventListeners`, `setupModuleStateListener`).
    [ ] Wire MessageRouter → Output instances by target moduleId (deliver trigger → onTriggerEvent, stream → onStreamingEvent)
        - Notes: In `setupTriggerEventListeners()`, subscribe router for each output module id:
          ```ts
          this.messageRouter.on(moduleInstance.id, (message) => {
            const actual = this.moduleInstances.get(moduleInstance.id);
            if (!actual) return;
            if (message.event === 'manualTrigger' || message.event === 'timeTrigger' || message.event === 'trigger') {
              actual.onTriggerEvent({ moduleId: message.source, moduleName: 'Input Module', event: message.event, payload: message.payload, timestamp: message.timestamp });
            } else if (message.event === 'stream') {
              actual.onStreamingEvent({ moduleId: message.source, moduleName: 'Input Module', value: message.payload, timestamp: message.timestamp });
            }
          });
          ```
          Pitfall: Don’t emit/forward to outputs before their `init()`; ensure instances are created first.
    [ ] Ensure input instances are started when appropriate; outputs mark connected/ready on start
        - Notes: Inputs (like Time) should auto-start if enabled. Outputs don’t need to play until they receive messages but can mark `isConnected=true` in `onStart()`.

[ ] 2. InteractorServer instance helpers (single source of truth)
    [ ] Implement getLiveInstance(id), ensureLiveInstance(id), startInstance(id), stopInstance(id)
        - Notes: Add private methods to `backend/src/index.ts` InteractorServer class:
          - `getLiveInstance(id): any | undefined` → `this.moduleInstances.get(id)`
          - `ensureLiveInstance(dataOrId): Promise<any>` → create (via `createModuleInstance`) if not present
          - `startInstance(id): Promise<void>` → ensure live, then `start()`; update state
          - `stopInstance(id): Promise<void>` → stop if live; update state
    [ ] Use helpers across routes (/start, /stop, /trigger, register) to avoid duplicate logic
        - Notes: Refactor handlers `/api/modules/instances/:id/start`, `/stop`, `/api/trigger/:moduleId` to use helpers.
          Pitfall: Keep state (`status`, `lastUpdate`) in sync with `StateManager.replaceState` after lifecycle actions.

[ ] 3. Base class refinements
    [ ] InputModuleBase: gate onStart() with config.enabled !== false; consolidate onManualTrigger() behavior
        - Notes: In `backend/src/modules/InputModuleBase.ts`, override `onStart()` to check `this.config?.enabled !== false` before calling `startListening()`.
          `onManualTrigger()` in Input base already emits a standard `manualTrigger`; modules should prefer `super.onManualTrigger()`.
          Pitfall: Don’t duplicate `manualTrigger()` in modules unless truly needed.
    [ ] OutputModuleBase: add getRouterHandler() helper to map Message → onTriggerEvent/onStreamingEvent
        - Notes: Add a method that returns a function `(message) => { ... }` that chooses `onTriggerEvent` vs `onStreamingEvent` based on `message.event`.
          Server can call `actualModule.getRouterHandler()` when wiring; or keep mapping in server and leave this optional.
    [ ] OutputModuleBase: add getFileUploadInfo() default helper; modules can extend
        - Notes: Provide a default shape `{ enabled?: boolean, host: string, port: number, maxFileSize?: number, allowedExtensions?: string[] }`.
          Audio/DMX modules can extend with module-specific fields.

[ ] 4. Interaction validation on register
    [ ] Validate unique module instance IDs and that all referenced manifests exist
        - Notes: In `/api/interactions/register` before saving, verify:
          - All `interaction.modules[].id` are unique
          - `moduleLoader.getManifest(module.moduleName)` exists for each module
    [ ] Validate routes: source/target IDs exist; source supports route.event; target is routable
        - Notes: For each `route`, ensure `source` and `target` match module ids in the same interaction.
          Check the source manifest `events` includes the `route.event` with `type: 'output'` (it emits this event).
          Optionally check the target manifest `type === 'output'` (will receive messages via server wiring).
    [ ] Return InteractorError.validation with actionable suggestions on failure
        - Notes: Use `InteractorError.validation(message, details, suggestions[])` to guide fixes.

[ ] 5. WebSocket protocol hygiene
    [ ] Standardize envelopes: state_update, module_runtime_update, trigger_event, error
        - Notes: Audit `setupWebSocket()`, `broadcastStateUpdate()`, `broadcastModuleRuntimeUpdate()`, `broadcastTriggerEvent()` in `backend/src/index.ts`.
          Ensure all outbound frames have `{ type, data, seq, timestamp }`.
    [ ] Add sequence numbers and timestamps to all WS messages
        - Notes: Maintain a simple `this.wsSeq` counter; increment per send.
    [ ] Debounce/batch state_update; emit module_runtime_update immediately for frequent changes
        - Notes: Debounce `broadcastStateUpdate()` (e.g., 100–200ms) to avoid floods; keep `module_runtime_update` immediate.
    [ ] Keep periodic fallback broadcast (tune interval)
        - Notes: Existing `setInterval(5000)` is fine; ensure it doesn’t conflict with debounce.

[ ] 6. MessageRouter resilience and visibility
    [ ] Add middleware chain (logging/metrics) before delivery
        - Notes: In `backend/src/core/MessageRouter.ts`, add an internal `middlewares: Function[]` and a `use(mw)` method (already present stub).
          Process middlewares in `routeMessage()` before `processRoute()` for logging/metrics.
    [ ] Implement a dead-letter queue (DLQ) for unrouted/failed messages with size cap
        - Notes: Add a circular buffer for DLQ in `MessageRouter`. Push when no routes match or when target delivery throws.
          Expose getter for server.
    [ ] Expose router stats and DLQ via /api/router/stats and /api/router/dlq
        - Notes: In `backend/src/index.ts`, add GET endpoints to return `getStats()` and DLQ contents (capped).

[ ] 7. Observability improvements
    [ ] Correlate messageId across logs from emission → routing → delivery
        - Notes: Ensure each message has a stable `id` and include it in all logs across Time emit, router route, and output handle.
    [ ] Add /api/logs?moduleId=... and /api/logs?messageId=... filters
        - Notes: Extend existing `/api/logs` to accept query params and filter recent logs from `Logger`.
    [ ] Ensure all errors use InteractorError with code and suggestions
        - Notes: Wrap external IO (fs, ffmpeg, network) with `InteractorError.moduleError` or `.validation` accordingly.

[ ] 8. FileUploader ergonomics
    [ ] Keep single global uploader (already present); verify /files/:moduleType and DELETE work consistently
        - Notes: The global instance is in `backend/src/services/fileUploaderInstance.ts`. Routes are exposed by the uploader on port 4000.
    [ ] Expose /upload/health endpoint from uploader; surface status via backend /api
        - Notes: If uploader has `GET /health`, proxy or report status at backend `/api/upload/health`.
    [ ] Document audio-output upload flow in backend README
        - Notes: Include example `curl -F "file=@path.wav" http://0.0.0.0:4000/upload/audio-output` and playback via Time → Audio routing.

[ ] 9. State persistence hygiene
    [ ] Coalesce/throttle StateManager writes (e.g., 50–200 ms) for runtime-only updates
        - Notes: Where we call `stateManager.replaceState({ modules })` on frequent runtime updates, wrap in a throttled function.
    [ ] Add integrity check on load; auto-restore latest good backup on corruption
        - Notes: On `StateManager.init()`, if parsing fails or schema invalid, restore from `backend/data/backups/`.
    [ ] Make backup count configurable and confirm rotation works
        - Notes: Use `config.interactions.backupCount`.

[ ] 10. Audio Output robustness
    [ ] Preflight file existence and extension before playback; produce clear audio_playback errors
        - Notes: In `backend/src/modules/output/audio_output/players/NodeSpeakerPlayer.ts`, when `data` is a string path, verify `fs.existsSync(filePath)` and extension allowed.
    [ ] Wrap ffmpeg and speaker failures in InteractorError with context (paths, args)
        - Notes: On exceptions around `FFmpeg` or `Speaker`, throw `InteractorError.moduleError('audio_playback', err)` with details.
    [ ] Emit granular playback state (start/pause/resume/stop) via emitRuntimeStateUpdate
        - Notes: In `AudioOutputModule`, call `emitRuntimeStateUpdate({ isPlaying, currentTime, duration, ... })` after state changes.

[ ] 11. Security and configuration
    [ ] Add optional auth gate (config.security.enableAuth) for admin routes
        - Notes: In `setupRoutes()`, guard mutation endpoints when enabled. Keep disabled by default per config.
    [ ] Enforce stricter CORS defaults in production; keep dev permissive
        - Notes: In `setupMiddleware()`, if `process.env.NODE_ENV==='production'`, set CORS origins from config.
    [ ] Validate upload MIME vs extension; sanitize filenames (already partially handled)
        - Notes: Extend `LocalFileSystemStorage.save()` to validate MIME if available; keep filename sanitation.

[ ] 12. Naming and cleanup
    [ ] Consider renaming ModuleLoader → ManifestRegistry to reflect responsibility
        - Notes: If done, keep a compatibility layer or update imports across backend.
    [ ] Mark backend/src/simple-server.ts as demo-only or remove to reduce confusion
        - Notes: Add header comment or delete if unused in any scripts.
    [ ] Remove dead code paths and comments that reference removed singletons
        - Notes: Search for `getInstance(id)` usage on ModuleLoader and remove.

[ ] 13. Smoke tests and scripts (fast, not unit tests)
    [ ] Add script to register Time(clock or metronome) → Audio route (event: timeTrigger)
        - Notes: POST to `/api/interactions/register` with one interaction containing Time and Audio modules and a route where `event` is `timeTrigger`.
    [ ] Start Time instance; verify router stats increment and Audio receives events
        - Notes: POST `/api/modules/instances/:timeId/start`; check `/api/router/stats` for delivered count > 0.
    [ ] Verify WebSocket emits state_update and module_runtime_update as expected
        - Notes: Connect a WS client to `ws://host:3001`, assert initial `state_update` then continuous `module_runtime_update` messages.

[ ] 14. Documentation updates
    [ ] Update backend README with routing semantics (no event remap), lifecycle, and WS envelopes
        - Notes: Clarify that router matches by `route.event` emitted by source; server translates message to output handlers.
    [ ] Add short "Backend Operations Guide" with common cURL calls for start/stop/update/register
        - Notes: Include examples for: list modules, create instance, start/stop, register interactions, trigger manual.

Execution notes
- Priorities: complete sections 1–4 first to unlock a working headless Time → Audio path. Then 5–7 for real-time polish and visibility. The rest improve robustness and DX.
- Acceptance for section 1: Time → Audio plays (or emits fallback tone) with routes using event "timeTrigger" and router stats showing successful deliveries.

Autonomous Agent Operations (read carefully)
- Prerequisites
  - Node.js 18+ installed; run `node -v`.
  - ffmpeg availability via `ffmpeg-static` is bundled; no external install required.
  - Windows notes: audio playback uses `speaker`; ensure default output device works. Close apps that lock the device.
  - Install deps at repo root then backend/shared:
    - `npm install` (root) if using workspaces, then `cd backend && npm install` and `cd ../shared && npm install` if needed.
- Command run order
  1) Backup state: copy `backend/data/state.json` to `backend/data/backups/state_<timestamp>.json` if exists.
  2) Make one logical edit at a time; after each group of edits:
     - Build/lint: `cd backend && npm run build || true && npm run lint || true` (don’t block on lint in early passes).
     - Run: `npm run dev` and validate health and affected endpoints.
  3) Only then proceed to next checklist section.
- Safety/rollback
  - If server fails to start after an edit, revert the last file(s) changed.
  - If state becomes inconsistent, restore latest backup from `backend/data/backups/` and restart.
- Idempotency
  - Ensure `/api/interactions/register` can be called repeatedly without duplicating routes or instances.
  - Clear routes via `messageRouter.clearRoutes()` before re-adding from interactions (already done; keep it).
- Duplicate listeners
  - Always remove existing listeners before attaching new ones to a given output instance (`removeAllListeners('stateUpdate')`, etc. already used in `setupModuleStateListener`).
  - When wiring router→output, make sure the subscription is established once per output id.
- Performance/backpressure
  - If router match volume spikes, log WARN and push extra messages to DLQ; do not block event loop.
- Logging discipline
  - Use `Logger` with module labels. Include `messageId` across source emit → router → output.
- Feature flags
  - Place toggles in `config/system.json` for new capabilities (`router.dlqEnabled`, `ws.debounceMs`, etc.).
- Frontend compatibility
  - WebSocket: only broadcast runtime updates as `module_runtime_update` and general state as `state_update`.
  - Do not send structural changes solely via WS; persist+expose via REST then broadcast minimal state.
- Verification scripts (examples)
  - Register interaction (Time→Audio): POST to `/api/interactions/register` with single interaction; event=`timeTrigger`.
  - Start Time: POST `/api/modules/instances/<timeId>/start`.
  - Observe logs for routed messages and Audio handler calls; check `/api/router/stats`.
- Deliverables
  - Keep a short CHANGELOG entry in this file (append “Done:” with date and commit hash if available).
  - Update documentation bullets once each section is completed.
